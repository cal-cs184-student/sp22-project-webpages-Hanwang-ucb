<html>
<head>
<title>cs284-p2</title>
<link href="css/style.css" type="text/css" rel="stylesheet" media="all">
<link href="css/bootstrap.css" type="text/css" rel="stylesheet" media="all">

<!-- js -->
<script src="js/jquery.min.js"></script>
<script src="js/modernizr.custom.js"></script>
<!-- //js -->	
<!-- start-smoth-scrolling-->
<script type="text/javascript" src="js/move-top.js"></script>
<script type="text/javascript" src="js/easing.js"></script>	
<script type="text/javascript" src="js/modernizr.custom.53451.js"></script>
<script type="text/javascript">
		jQuery(document).ready(function($) {
			$(".scroll").click(function(event){		
				event.preventDefault();
				$('html,body').animate({scrollTop:$(this.hash).offset().top},1000);
			});
		});
</script>
<!--//end-smoth-scrolling-->

</head>
<body>
<!-- <body oncontextmenu='return false' ondragstart='return false' onselectstart ='return false' onselect='document.selection.empty()' oncopy='document.selection.empty()' onbeforecopy='return false' onmouseup='document.selection.empty()'> -->
	<!--header-->
	<div class="header">
		<div class="container">
			<div class="header-class">
				<h1 style="color:white;"></a>CS284</a></h1>
			</div>
		</div>	
	</div>
	<!--//header-->
	<!--report-->
	<div class="report">
		<div class="container">
			<div class="fav-app">
				<h3>Reprot of Project 2: Mesh Edit</h3>
				<h5 style="font-size:18px;">Han Wang</h5>				
				<h6>Submitted on Mar 2, 2022</h6>
				<div class="sngl-img">
					<img src="images/first.png" class="img" /> </a>
				</div>
				<h6>Bug Art: Origami art of teapot. Generated by wrong coefficient in unsample function.<h6>
				
				<h4>Overview</h4>
				<p style="font-size:20px;">In this project, I got my hands on the mesh editing operation. In the first section, I implemented the evaluate operation for Bezier curve and Bezier surface based on de Casteljau algorithmã€‚In the second section I implemented area-Weighted vertex normals to make the texture smoother. I also implemented the flip and split operations on edge, which is a great practice for pointer management. And based on that I implemented the subdivision of mesh to generat a new mesh with "higher resolution".
				</p><br><br>
				
				<h3 style="font-size:30px;line-height:10%">Section I: Bezier Curves and Surfaces</h3>


				<h4>Part 1: Bezier Curves with 1D de Casteljau Subdivision</h4>


				<p style="font-size:20px;"><b>Briefly explain de Casteljau's algorithm and how you implemented it in order to evaluate Bezier curves.</b><br><br>

				De Casteljau's algorithm is designed to evaluate Bezier curves defined by endpoints and control points. In each iteration of de Casteljau's algorithm, it creates a new level of linear interpolation(lerp) control points, which means inserts a lerp control point between each adjacent control point of target Bezier curve. The lerp control points inserted in the previous iteration will be used by the lerp operation in the next iteration. This iteration is repeated until the newly inserted lerp control points level contains only one point. <br><br>

				De Casteljau's algorithm is implemented in <code>BezierCurve::evaluateStep()</code> taking the pointer of latest control point level <code>&points</code> as input. Everytime <code>evaluateStep()</code> is called, it creates total <code>n = points.size()</code> new control points by calling inline function <code>lerp()</code> by <code>n</code> times. The output points of <code>lerp()</code> are <code>.pushback()</code> by a <code>std::vector</code> which is the container of new control point layer and the output of <code>evaluateStep()</code>.

				<br><br>

				<b>Create your own Bezier curve with 6 control points of your choosing. Use this Bezier curve for your screenshots below. Show screenshots of each step / level of the evaluation from the original control points down to the final evaluated point. </b><br><br></p>

				<div class="div1">
					<img src="images/part1_BC.png" width="1000"/> </a>
				</div>
				<h5>Bezier Curves from the original control points down to the final evaluated point</h5>


				<p style="font-size:20px;"><b>Show a screenshot of a slightly different Bezier curve by moving the original control points around and modifying the parameter <code>t</code> .</b><br><br>


				

				<div class="sngl-img">
					<img src="images/part1_BC2.png" class="img" width="1000" /> </a>
				</div>
				<h5>Different Bezier curve with modified original control points</h5>
				
				<div class="div1">
					<img src="images/part1_t.gif"/> </a>
				</div>
				<h5>Bezier Curves changing with the change of <code>t</code></h5>




				<h4>Part 2: Bezier Surfaces with Separable 1D de Casteljau</h4>


				<p style="font-size:20px;"><b>Briefly explain how de Casteljau algorithm extends to Bezier surfaces and how you implemented it in order to evaluate Bezier surfaces.</b><br><br>

				The essence of evaluating Bezier surface is to broaden the Bezier curve to the grid by adding an extra dimension to it. Accordingly, we need two parameters <code>u, v</code> to evaluate the Bezier curve in two dimensions, instead of one parameter <code>t</code>. The extra dimension also carries an extra iteration of the de Casteljau algorithm. First de Casteljau's algorithm obtains the singular control point at last level of the Bezier curve consisting of each row of control points with parameter <code>u</code>. Then iterate on it again based on those points with parameter <code>v</code> to get one last point.<br><br>

				Evaluation of Bezier surface is implemented in <code>BezierPatch::evaluate()</code> <code>BezierPatch::evaluate1D()</code> and <code>evaluateStep()</code> for 3D vector. A container <code>row_singular_pts</code> is defined in <code>evaluate()</code> for singular control points at last levels in first iteration, which are obtained by repeatly calling <code>evaluate1D()</code> with parameter <code>u</code> and instances in pointer <code>&controlPoint</code>. Then <code>evaluate1D()</code> will be called one more time with parameter <code>v</code> and <code>row_singular_pts</code> to get the last similar point.

				<br><br>

				<b>Show a screenshot of <code>bez/teapot.bez</code> evaluated by your implementation.</b><br><br>
				
				</p>
				

				<div class="sngl-img">
					<img src="images/part2_teapot.png" class="img"/> </a>
				</div>
				<h5><code>bez/teapot.bez</code><h5><br><br><br><br>
				
				<h3 style="font-size:30px;line-height:10%">Section II: Triangle Meshes and Half-Edge Data Structure</h3>
	
				<h4>Part 3: Area-Weighted Vertex Normals</h4>



				<p style="font-size:20px;"><b>Briefly explain how you implemented the area-weighted vertex normals.</b><br><br>

				The area-weighted vertex normals is implemented in <code> Vertex::normal()</code>, wherein we use a <code>HalfedgeCIter hfedge</code> for iteration. In each iteration, the cross product of the two adjacent sides of the triangle is used to calculate the area. Normed result is added to the vector container <code>Vector3D normed_ver</code>. Then the iterator is moved to <code>hfedge->twin()->next()</code>. This loop repeats until back to the starting half edge.<br><br>

				<b>Show screenshots of dae/teapot.dae comparing teapot shading with and without vertex normals.</b><br><br></p>

				
				<div class="sngl-img">
					<img src="images/part3_teapot.png" class="img" width="1000" /> </a>
				</div>
				<h5><code>dae/teapot.dae</code> with flat shading(left) and Phong shading(right)<h5>


				<h4>Part 4: Edge Flip</h4>


				<p style="font-size:20px;"><b>Briefly explain how you implemented the edge flip operation and describe any interesting implementation / debugging tricks you have used.</b><br><br>
 				
 				The edge flip operation is implemented in <code>HalfedgeMesh::flipEdge()</code>. It's all about pointer management. At beginning, I tried to list the objects involved in each reassignment step with their corresponding memory addresses, to identify the unnecessary operations and the objects that do not need to be reallocated in a particular case, in order to simplify the algorithm flow and reduce the workload. However, compared to naive reassignment of all half edges, the process based on conditional judgments causes many unforeseen bugs. In the end, the naive reassignment for all related objectives, the not-optimal but indeed the most intuitive form of code, was retained.
 				

 				<br><br>

 				<b>Show screenshots of the teapot before and after some edge flips.</b><br><br>

				</p>
				

				
				<div class="sngl-img">
					<img src="images/part4_teapot.png" class="img" width="1000" /> </a>
				</div>
				<h5>Teapot before(left) and after(right) some edge flips</h5><br><br>

				

				<p style="font-size:20px;"><b>Write about your eventful debugging journey, if you have experienced one.</b><br><br>

				I only included numbers in the names of the two half edges of the input edge <code>e0</code>, as <code>hfedge_0</code> and <code>hfedge_1</code>. The rest are named by <code>hfedge_0(or 1)_methods</code>. Similar to face and vertices. Things are getting better after I changed the name of <code>h_6</code> to <code>hfedge_0_next_next_twin</code> since they are apparently more informative.<br><br> 

				</p>




				<h4>Part 5: Edge Split</h4>
			
				
				<p style="font-size:20px;"><b>Briefly explain how you implemented the edge split operation and describe any interesting implementation / debugging tricks you have used.</b><br><br>


				Edge split was implemented in <code>HalfedgeMesh::splitEdge()</code>. The implementation of split is very similar to flip: for an input's edge <code>e0</code>, get pointers to its related half edge, vertice and face, and reassign them after adding three or four edges. Boundary was not support in the submission version.

				<br><br>

				<b>Show screenshots of a mesh before and after some edge splits.</b><br><br></p>

				<div class="sngl-img">
					<img src="images/part5_splits.png" class="img" width="1000" /> </a>
				</div>
				<h5>Cow mesh before(left) and after(right) edge splits</h5><br><br>

				<p style="font-size:20px;"><b>Show screenshots of a mesh before and after a combination of both edge splits and edge flips.</b><br><br></p>

				<div class="sngl-img">
					<img src="images/part5_splits_flips.png" class="img" width="1000" /> </a>
				</div>
				<h5>Cow mesh before(left) and after(right) edge splits and flips</h5><br><br>





				</p>
<!-- 
				<p style="font-size:20px;"><b>If you have implemented support for boundary edges, show screenshots of your implementation properly handling split operations on boundary edges.</b><br><br></p>

				<div class="sngl-img">
					<img src="images/part5_boundary.png" class="img"/> </a>
				</div>
				<h5>Support for boundary edges</h5><br><br> -->
						

				<h4>Part 6: Loop Subdivision for Mesh Upsampling</h4>
							
				
				<p style="font-size:20px;"><b>Briefly explain how you implemented the loop subdivision and describe any interesting implementation / debugging tricks you have used.</b><br><br>

				The loop subdivision is implemented in <code>MeshResampler::upsample()</code>. For a given pointer of mesh <code>mesh</code>, its veritces and edges are firstly looped through. Vertices are assigned new position after subdivision. Edges are inserted with a new interpolated vertices. Both vertices and edges will be marked as <code>isNew=0</code> after loop. In the next step each old edge is split, the generated vertex is marked as <code>isNew=1</code>, of which the position is assigned to the <code>newPosition</code> of corresponding edge. After that, all the edges with one <code>isNew=0</code> vertice and <code>isNew=1</code> vertice are flipped. Last, <code>newPosition</code> are set as <code>position</code> for all vertices.

				<br><br>


				<b>Take some notes, as well as some screenshots, of your observations on how meshes behave after loop subdivision. What happens to sharp corners and edges? Can you reduce this effect by pre-splitting some edges?</b><br><br>
				

				The sharp corners will gradually become rounded with subdivision, just like the horns in cow mesh lose their angles with subdivision. Pre-splitting mitigates this effect, as shown in the gif of the cube, where the pre-splitted sharp information is retained after subdivision.




				<br><br></p>

				<div class="sngl-img">
					<img src="images/part6_1.png" class="img" width="1000" /> </a>
				</div>
				<h5>Cow mesh defaul(left) and unsampled(right)</h5><br><br>

				<div class="sngl-img">
					<img src="images/part6_2.gif" class="img" /> </a>
				</div>
				<h5>Cow mesh unsampled twice</h5><br><br>

				<div class="sngl-img">
					<img src="images/part6_sharp.gif" class="img" /> </a>
				</div>
				<h5>Pre-splitted corner</h5><br><br>


				<p style="font-size:20px;"><b>Load <code>dae/cube.dae</code>. Perform several iterations of loop subdivision on the cube. Notice that the cube becomes slightly asymmetric after repeated subdivisions. Can you pre-process the cube with edge flips and splits so that the cube subdivides symmetrically? Document these effects and explain why they occur. Also explain how your pre-processing helps alleviate the effects.</b><br><br>

				The reason for the asymmetry is that the division of each face of the cube is asymmetric. A pre-split of the edges on each cube face can effectively alleviate the asymmetry cased by subdivision.<br><br></p>



				<div class="sngl-img">
					<img src="images/part6_cube1.png" class="img" width="1000" /> </a>
				</div>
				<h5>Cube mesh getting asymmetric after unsampled</h5><br><br>

				<div class="sngl-img">
					<img src="images/part6_cube2.png" class="img" width="1000"/> </a>
				</div>
				<h5>Alleviate asymmetric effect by spliting edges on faces</h5><br><br>

				
				
	<!--//report-->
	










	<!--smooth-scrolling-of-move-up-->
		<script type="text/javascript">
			$(document).ready(function() {
				/*
				var defaults = {
					containerID: 'toTop', // fading element id
					containerHoverID: 'toTopHover', // fading element hover id
					scrollSpeed: 1200,
					easingType: 'linear' 
				};
				*/
				
				$().UItoTop({ easingType: 'easeOutQuart' });
				
			});
		</script>
		<a href="#" id="toTop" style="display: block;"> <span id="toTopHover" style="opacity: 1;"> </span></a>
	<!--//smooth-scrolling-of-move-up-->	
</body>
</html>
